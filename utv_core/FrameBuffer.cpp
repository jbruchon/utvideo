/* 文字コードはＳＪＩＳ 改行コードはＣＲＬＦ */
/* $Id$ */

#include "stdafx.h"
#include "utvideo.h"
#include "FrameBuffer.h"

CFrameBuffer::CFrameBuffer(void)
{
	for (int i = 0; i < MAX_PLANE; i++)
	{
		m_pAllocatedAddr[i] = NULL;
		m_pBufferAddr[i] = NULL;
	}
	m_nPlanes = 0;
}

CFrameBuffer::~CFrameBuffer(void)
{
	for (int i = 0; i < MAX_PLANE; i++)
	{
		if (m_pAllocatedAddr[i] != NULL)
		{
#ifdef _WIN32
			VirtualFree(m_pAllocatedAddr[i], 0, MEM_RELEASE);
#endif
#if defined(__APPLE__) || defined(__unix__)
			munmap(m_pAllocatedAddr[i], m_cbAllocated[i]);
#endif
		}
	}
}

void CFrameBuffer::AddPlane(size_t cbBuffer, size_t cbMargin)
{
#ifdef _WIN32
	SYSTEM_INFO si;
#endif
	size_t cbAllocateUnit;
	size_t cbAllocated;
	uint8_t *pAllocatedAddr;
	/*
	 * プレーンごとに開始アドレスを少しずつずらし、キャッシュのスラッシングを回避する。
	 * オフセットは、
	 *   - キャッシュラインサイズ（最近の多くのプロセッサでは 64 バイト）の整数倍でなければならない
	 *   - L1 キャッシュの 1way のサイズをプレーン数で割った値が望ましい
	 * 最近の Intel のプロセッサでは 1way のサイズが 4KiB で、プレーン数は最大で 4 なので、
	 * オフセットは 1KiB が適切となる。
	 * 
	 * 他の最近のプロセッサでも 1way のサイズが 4KiB より小さいことはないので、この値で問題ない。
	 * Arm とかを考え始めるとまた違うかもしれないが、 1way のサイズが 4KiB より小さいような
	 * 小規模なプロセッサで UtVideo を使うことはないだろう。
	 */
	size_t cbOffset = m_nPlanes * 1024;

#ifdef _WIN32
	GetSystemInfo(&si);
	cbAllocateUnit = si.dwPageSize;
#endif
#if defined(__APPLE__) || defined(__unix__)
	cbAllocateUnit = getpagesize();
#endif
	cbMargin = ROUNDUP(cbMargin, cbAllocateUnit);
	cbAllocated = cbMargin + ROUNDUP(cbBuffer + cbMargin + cbOffset, cbAllocateUnit);

#ifdef _WIN32
	pAllocatedAddr = (uint8_t *)VirtualAlloc(NULL, cbAllocated, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pAllocatedAddr == NULL)
		return;
#endif
#if defined(__APPLE__) || defined(__unix__)
	pAllocatedAddr = (uint8_t *)mmap(NULL, cbAllocated, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
	if (pAllocatedAddr == MAP_FAILED)
		return;
#endif

	m_pAllocatedAddr[m_nPlanes] = pAllocatedAddr;
	m_cbAllocated[m_nPlanes] = cbAllocated;
	m_pBufferAddr[m_nPlanes] = pAllocatedAddr + cbMargin + cbOffset;

	m_nPlanes++;

	return;
}
